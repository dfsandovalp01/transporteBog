extensions [nw table]
;;;;;;;;;;;;;;;
;; FUNCTIONS ;;
;;;;;;;;;;;;;;;


to setup
  clear-all
  setup-importer
  setup-portales
  setup-conectores
;  setup-estaciones
  
  set all_portales sort [who] of vertices with [tipo = "PORT"] 
 
  set prob_of_service read_table "distributions/prob.csv"
	set gm_org read_gm "distributions/org.csv"
	set gm_dest read_gm "distributions/dest.csv"
  setuptrans
;  repeat 2 [setuptrans]
;  setup-transmilenio
  setup-people
;  crear-vias
;  set conectores (list )
  reset-ticks
end

to setup-portales
  ask vertices
  [if tipo = "PORT" 
    [set shape "house"
     set color green
     set size 0.6]
  ]
end

to setup-conectores
  ask vertices
  [if tipo = "ORI" 
    [set shape "circle"
     set color yellow
     set size 0.4]
  ]
end


;to setup-transmilenio 
;  
;  let Portales.who sort [who] of vertices with [tipo = "PORT"]  
;
;  
;  while [empty? Portales.who = FALSE] [
;    
;    
;   let ind.Portal item 0 Portales.who
;    
;     create-transmilenio 8 [
;      set shape "truck"
;      set color red           
;      setxy [xcor] of vertex item 0 Portales.who  [ycor] of vertex item 0 Portales.who      
;      set direct "DOWN"     
;      set size 0.6
;      set path [];list ("x") (origen.stop)
;      set speed 0.1 + random-float 0.9
;      
;      
;    ]
;    let transmiAsig sort [who] of transmilenio-on vertex item 0 Portales.who       
;    let portalesTo sort [who] of vertices with [tipo = "PORT"]
;      set portalesTo remove-item position ind.Portal portalesTo portalesTo
;    
;    while [empty? transmiAsig = FALSE][
;      
;      ask articulado item 0 transmiAsig [
;        set portOri vertex item 0 Portales.who
;        set portDest vertex item 0 portalesTo
;        set origen.stop portOri
;      ]
;      set transmiAsig remove-item 0 transmiAsig
;      set portalesTo remove-item 0 portalesTo
;      
;    ]
;    set Portales.who remove-item 0 Portales.who
;  ] 
;  
;
;
;end

to setuptrans
  
  let Portales.who sort [who] of vertices with [tipo = "PORT"]

;  repeat cant_cuadrillas [
;    foreach all_portales [
;      n -> set portalesTo lput n []
;      
;    ]
;  ]  
  set portalesTo sort [who] of vertices with [tipo = "PORT"]
  
  foreach Portales.who [ 
    n -> create-transmilenio 8 [
      set shape "truck"
      set color red           
      setxy [xcor] of vertex n [ycor] of vertex n
      set direct "DOWN"     
      set size 0.6
      set path [];list ("x") (origen.stop)
      set speed 0.1 + random-float 0.9
       
    
      
      ]  
  ]
    
    foreach Portales.who [
      m -> 
      (foreach (sort [who] of transmilenio-on vertex m) (remove m portalesTo)
        [ [o p] -> ask articulado o [
;          set portalesTo remove m portalesTo
          set portOri vertex m
          set portDest vertex p
          set origen.stop portOri
        ]
      ])
    ]
  

       
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;

to setup-people
  create-people number_of_people [
    setxy random-xcor random-ycor
    set shape "person"
    set color white
    set size 0.5
;    set inicio one-of vertices
    set llegada one-of vertices
    set destination place_from_gaussian_mixture 0 0 -1 gm_dest
		span_from_gaussian_mixture 0 0 -1 gm_org
;    set inicio vertex 56
;    set llegada vertex 53
    
  ]
end



;;;;;;;;;;;;;;;;;;;;;;; GO ;;;;;;;;;;;;;;;;;;;;;;

to go
  ask transmilenio [
    move-articulado
    return-articulado
    give-path
  ]
  
;  ask transmilenio [mover-transmi-from-stop]
  move-people
  tick-advance 0.1
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PROCEDIMIENTOS TRANSMILENIO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to move-articulado
  
;  if [direct] of transmilenio = "DOWN";any? vertices with [direct = "DOWN"] = TRUE
  let Portales.who sort [who] of vertices with [tipo = "PORT"]  ;[54 57 64 78 96 107 123 134 147]
  let connector.id [0 10 17 24 27 38 47 50]
  let connector.path [
    [51 55 1 1 1 1 1 1 1] ;0
    [9 9 11 12 12 15 15 15 15] ;10
    [11 11 58 11 11 18 18 18 18] ;17
    [14 14 14 65 79 25 25 25 25] ;24 
    [16 16 16 16 16 28 29 28 29] ;27
    [28 28 28 26 26 97 39 39 39] ;38
    [37 37 37 37 37 37 108 48 48] ;47
    [46 46 46 46 46 46 49 124 135];50
  ]
  
  ;;;;;;; ARTICULADOS BAJANDO ;;;;;;;;;;;;;;
  ask transmilenio with [direct = "DOWN"]  
  [
    ifelse member? [who] of origen.stop  connector.id  = TRUE
    [      
      let connector.position position [who] of origen.stop connector.id ; posicion del conector en el arreglo
      let destination.position position [who] of portDest Portales.who ; posicion del portal de destino en el arreglo
      set next.stop vertex item destination.position item connector.position connector.path
      let next.stop_x [xcor] of next.stop
      let next.stop_y [ycor] of next.stop
      ;;; PRUEBA
;      face next.stop
;      fd 0.2
      ;;;
      facexy next.stop_x next.stop_y fd distance next.stop
      ifelse [who] of origen.stop < [who] of next.stop 
      [
        set direct "UP"
      ]
      [
        set direct "DOWN"
      ]
      set last.stop origen.stop
      set origen.stop next.stop
      set path remove-duplicates path
      
    ]
    [
      let origen origen.stop
      
      
      set next.stop item 0 [end1] of links with [end2 = origen ];of transmilenio]
                                                                ;      set options.stop  [end2] of links with [end1 = id.origen.stop ]
      let next.stop_x [xcor] of next.stop
      let next.stop_y [ycor] of next.stop
      ;;; PRUEBA
;      face next.stop
;      fd 0.2
      ;;;
      facexy next.stop_x next.stop_y fd distance next.stop
      set last.stop origen.stop
      set origen.stop next.stop
      set next.stop item 0 [end1] of links with [end2 = origen ]
      set path remove-duplicates path
     
    ]
    set path remove-duplicates path
     ]
  
  ;;;;;;; ARTICULADOS SUBIENDO;;;;;;;;;;;;;;
  ask transmilenio with [direct = "UP"]  
  [
    ifelse member? [who] of origen.stop  connector.id  = TRUE
    [      
      let connector.position position [who] of origen.stop connector.id ; posicion del conector en el arreglo
      let destination.position position [who] of portDest Portales.who ; posicion del portal de destino en el arreglo
      set next.stop vertex item destination.position item connector.position connector.path
      let next.stop_x [xcor] of next.stop
      let next.stop_y [ycor] of next.stop
      ;;; PRUEBA
;      face next.stop
;      fd 0.2
      ;;;
      facexy next.stop_x next.stop_y fd distance next.stop
      ifelse [who] of origen.stop < [who] of next.stop 
      [
        set direct "UP"
      ]
      [
        set direct "DOWN"
      ]
      set last.stop origen.stop
      set origen.stop next.stop
      set path remove-duplicates path

      
    ]
    [
      let origen origen.stop
      
      
      set next.stop item 0 [end2] of links with [end1 = origen ];of transmilenio]
                                                                ;      set options.stop  [end2] of links with [end1 = id.origen.stop ]
      let next.stop_x [xcor] of next.stop
      let next.stop_y [ycor] of next.stop
      ;;; PRUEBA
;      face next.stop
;      fd 0.2
      ;;;
      facexy next.stop_x next.stop_y fd distance next.stop
      set last.stop origen.stop
      set origen.stop next.stop
      set next.stop item 0 [end2] of links with [end1 = origen ]
      set path remove-duplicates path
      
      
    ]
    set path remove-duplicates path
    
     ]
  
  
    
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to return-articulado
  ;;; ESTA PARTE DUVUELVE AL ARTICULADO
  ask transmilenio 
  [
    ifelse portdest = origen.stop
    [
      set portDest portOri
      set portOri origen.stop
      set direct "DOWN"
    ]
    []
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; IDENTIFICANDO CAMINOS ;;;;;;;;;;;;;;;;;;;;;;

to give-path
  ask transmilenio [    
    set path lput origen.stop path 
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  PROCEDIMIENTOS PERSONAS  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to move-people ;; lleva a las personas a la estacion mas cercana
  ask people
    [
      let vertex-to-move min-one-of (vertices) [distance myself]
      move-to vertex-to-move
      set inicio vertex-to-move
      
      ifelse any? transmilenio-here = TRUE
;      ifelse inicio = [origen.stop] of transmilenio-here
      [
;        ifelse member? llegada [path] of transmilenio-here; with [origen.stop = inicio] = TRUE 
;        [
          set color green
          user-message (word "SOY " who " Y ESTE ME SIRVE :)")
          beep
;        ]
;        []
      ]
      []
    ]
  
end

; ------- read distribution from csv -------
to-report read_table [file]
	let prob []
	let counter 0

	file-close-all
	file-open file
	let data csv:from-row file-read-line

	while [not file-at-end?][
		let row csv:from-row file-read-line
		repeat item 0 row - counter + 1 [
			let entry []
			set entry lput counter entry
			set entry lput item 1 row entry
			set prob lput entry prob
			set counter counter + 1
		]
	]

	file-close
	report prob
end

to-report read_gm [file]
	; create list
	let gm []

	file-close-all
	;file-open "distributions/org.csv"
	file-open file
	let data csv:from-row file-read-line
	let hour -1
	let hour_old 100
	let gm_hour []

	while [not file-at-end?][
		let row csv:from-row file-read-line
		set hour item 1 row

		if hour > hour_old [
			set gm lput gm_hour gm
			set gm_hour []
		]

		set gm_hour lput row gm_hour
		set hour_old hour
	]
	set gm lput gm_hour gm

	file-close
	report gm
end
; -----------------------------------------

; ------- span from gaussian mixture distribution --------

to-report place_from_gaussian_mixture [ m n threshold dists ]
	ifelse item 1 item 0 item m dists < floor time [
		; recursive
		set m m + 1
		report place_from_gaussian_mixture m n threshold dists
	][
		if threshold = -1 [
			set threshold random-float 1
		]
		ifelse item 5 item n item m dists >= threshold [
			let mean_x item 2 item n item m dists
			let mean_y item 3 item n item m dists
			let std item 4 item n item m dists
			report place_with_mean_and_std mean_x mean_y std
		][
			set n n + 1
			report place_from_gaussian_mixture m n threshold dists
		]
	]
end

to-report place_with_mean_and_std [ mean_x mean_y std ]
	let xcord random-normal mean_x std
	let ycord random-normal mean_y std

	if xcord > max-x [set xcord max-x]
	if ycord > max-y [set ycord max-y]
	if xcord < 0 [set xcord 0]
	if ycord < 0 [set ycord 0]

	let vertex-to-move min-one-of (vertices) [ distancexy xcord ycord ]

	; old code back where this function spaned the agent
	;set xcor xcord
	;set ycor ycord

	report vertex-to-move

end

to span_from_gaussian_mixture [ m n threshold dists ]
	let vertex-to-move place_from_gaussian_mixture 0 0 -1 dists
	set current_vertice vertex-to-move
	move-to vertex-to-move
end
; -----------------------------------------------------------
